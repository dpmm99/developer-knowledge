<html>
<head>

<style>
h2 {
	margin-left: 8px;
	display: inline-block;
}

.children {
	margin-left: 2em;
}

.accordion.collapsed .children {
	display: none;
}

.accordion > .arrow {
	cursor: pointer;
}
.accordion > .arrow:before {
	content: '\25bc';
	font-size: 150%;
}
.accordion.collapsed > .arrow:before {
	cursor: pointer;
	content: '\25ba';
}
.accordion > .arrow:focus {
	color: red; /*Make it esay to see when the user has an arrow in-focus*/
}

.permalink {
	text-decoration: none;
	color: #000;
	padding-left: 0.5em;
	opacity: 0.6;
}
.permalink:hover {
	opacity: 1.0;
}
.notice {
	position: fixed;
	background-color: #afc;
	padding: 10px;
	border-radius: 1em;
	opacity: 1.0;
	transition: opacity 1s;
	z-index: 2;
}

.pop-button {
	border-radius: 50%;
	background-color: #59f;
	color: #fff;
	text-decoration: none;
	padding: 0 5px;
}

.pop-button.checked-pop-button {
	background-color: #bbb;
}

.pop-panel {
	position: fixed;
	z-index: 2;
	background-color: #eee;
	border: 1px solid black;
	border-radius: 10px;
	padding: 8px;
	box-sizing: border-box;
}

.pop-backdrop {
	position: fixed;
	left: 0;
	top: 0;
	width: 100vw;
	height: 100vh;
	z-index: 1;
}

/*Experimental readability styling*/
.columnize {
	margin: 0 10%;
}
.columnize > * {
	display: inline;
}
@media (min-width: 50em) {
	.columnize {
		column-count: 2;
		margin: 0 5%;
	}
}
@media (min-width: 100em) {
	.columnize {
		column-count: 3;
		margin: 0;
	}
}
@media (min-width: 150em) {
	.columnize {
		column-count: 4;
	}
}

/*Give the checkboxes larger targets*/
input[type="checkbox"] {
	height: 2em;
	width: 2em;
	vertical-align: middle;
	margin-top: 0px;
}

#dropzone {
	position: fixed;
	right: 0;
	left: 0;
	top: 0;
	bottom: 0;
	background-color: #000a;
	padding: 5vw;
}
#dropzone > div {
	height: 100%;
	border: 3px dashed #fff;
	box-sizing: border-box;
	text-align: center;
	color: #fff;
	font-size: 200%;
	line-height: calc(100vh - 10vw);
}
</style>
</head>
<body ondragenter="dragEnter(event)">

<h1>Facts, Ideas, and Principles for Becoming Your Best (Software Developer) Self</h1>
<div class="columnize">
<!--Had to use non-breaking spaces to indent because the 'columns' style doesn't work well with non-inline elements, and inlined paragraphs don't obey text-indent (other than the first paragraph)-->
<p>&nbsp; &nbsp; &nbsp; There is a vast amount of knowledge in the world, but much of it is sparsely distributed through wordy blog entries, articles, and books. The authors of these writings, as good authors tend to do, offer many examples and in-depth discussion of the concepts. However, most compositions cover a limited selection of concepts within the composition's already limited scope. This is not conducive to already knowledgeable individuals refreshing their knowledge or looking for realizations that have thus far escaped their judgment, nor does it function as guidance for novices seeking direction. As such, I offer this dense collection of a broad variety of facts, ideas, and principles in the hope that it can be a powerful, concise reference for experienced software developers (and related individuals) in their journey to become masters of all things surrounding their profession.</p>
<br>
<p>&nbsp; &nbsp; &nbsp; This page provides checkboxes to record your progress as you read individual items. The date and time of the moment you check each checkbox is saved in local storage. Because one can read through the items at any level or read the high-level items in one pass and the lower-level ones in another pass, consider each checkbox to apply only to the text directly adjacent to it.</p>
</div>
<section id="masternode"></section>

<div style="position:fixed;bottom:0;left:0;background-color:#eee;padding:3px;border-radius:5px;">
<button type="button" onclick="saveProgressAsFile()">Save progress as file</button>
Load progress file:
<input type="file" onchange="loadProgressFile(event, event.target.files)" accept=".json">
<button type="button" onclick="goToLastChecked()">Go to last checked item</button>
</div>

<div style="display: none;" id="dropzone" ondragleave="setDropZoneVisible(false)" ondragover="dragOver(event)" ondrop="dropInProgressFile(event)">
<div>
Drop a progress file anywhere to load it.
</div>
</div>

<script>
/**
 * Enum for possible appearances of a KnowledgeNode
 */
const DisplayMode = {
	/**
	 * Display as a single item. Can have POP children. <a> nodes with data-index are replaced by the child with the corresponding index.
	 */
	ITEM: "item",
	/**
	 * Display as a general description of an accordion list of items. Can have ITEM and ACCORDION children, which are placed in the node with the class "children".
	 * The first DOM element in the content is treated as the toggle button.
	 */
	ACCORDION: "accordion",
	/**
	 * Display as a tooltip. Cannot have children.
	 */
	POP: "pop"
}

const MAX_DEPTH = 4;

class KnowledgeNode {
	/**
	 * @param {int} id Permanent unique ID for this knowledge node. These should not change between updates, and there should be no duplicates.
	 * @param {DisplayMode} displayMode How this item should be displayed (options are "item", "accordion", "pop")
	 * @param {string} content HTML content to display
	 * @param {Array} children Array of KnowledgeNodes that this one contains (which would be checked if you check this node, and this node would be checked if you check all the children)
	 * @param {bool} hasCheckbox This item should have a checkbox (intended to be set to false for top-level categories which do not stand on their own as knowledge items)
	 */
	constructor(id, displayMode, content, children, hasCheckbox = true) {
		this.id = id;
		this.displayMode = displayMode;
		this.content = content;
		this.children = children || [];
		this.checked = KnowledgeNode.allNodes[this.id] || null; //Normally undefined, but we can fill that array with dates from localStorage when first loading the page, before creating any KnowledgeNodes.
		this.domCheckboxes = [];
		this.hasCheckbox = hasCheckbox;
		this.permalinkTarget = null;
		
		//Track all created nodes in a flat list. Ensure that no two nodes have the same ID.
		//Check either that it doesn't exist or that whatever exists there doesn't have a truthy "id" property (assuming Date won't ever have 'id')
		console.assert(!KnowledgeNode.allNodes[this.id] || !KnowledgeNode.allNodes[this.id].id, "Duplicate KnowledgeNode ID " + this.id);
		KnowledgeNode.allNodes[this.id] = this;
	}
	
	/**
	 * Creates and returns a DOM node for displaying this KnowledgeNode and all its descendants
	 * @param {int} depth Recursion depth (for debug assertion)
	 */
	toNode(depth = 0) {
		console.assert(depth <= MAX_DEPTH, "Exceeded max depth when constructing node for KnowledgeNode ID " + this.id);
		//Generate a DOM node depending on displayMode
		switch (this.displayMode) {
			case DisplayMode.ITEM:
				var item = document.createElement("p");
				item.innerHTML = this.content;
				
				var referencedChildren = this.children.map(p => 0); //Parallel to this.children; each element indicates the reference count for the child with the same index
				var pops = item.getElementsByTagName("a");
				for (var x = 0; x < pops.length; x++) {
					if (pops[x].dataset.index !== undefined) { //Check for data-index. If it has it, replace that element with the child whose index matches data-index.
						var idx = parseInt(pops[x].dataset.index);
						referencedChildren[idx]++; //Increment reference count for assertion
						console.assert(idx >= 0, "Negative or non-numeric data-index found ('" + pops[x].dataset.index + "') in KnowledgeNode ID " + this.id);
						console.assert(idx < this.children.length, "Found out-of-bounds data-index (" + idx + "; should be less than " + this.children.length + ") in KnowledgeNode ID " + this.id);
						
						pops[x].replaceWith(this.children[idx].toNode(depth + 1));
					} else console.assert(pops[x].href || pops[x].onclick, "Found an 'a' tag with neither a href nor an onclick event handler in KnowledgeNode ID " + this.id); //Probably a mistake
				}
				
				console.assert(referencedChildren.every(p => p > 0), "Unreferenced child " + referencedChildren.findIndex(p => p == 0) + " in KnowledgeNode ID " + this.id);
				console.assert(referencedChildren.every(p => p <= 1), "Repeat data-index " + referencedChildren.findIndex(p => p > 1) + " in KnowledgeNode ID " + this.id);
				
				//Checkbox
				item.insertBefore(this.makeCheckbox(), item.firstChild);
				
				item.appendChild(this.makePermalink());
				
				if (!this.permalinkTarget) this.permalinkTarget = item;
				
				//Wrap it all up in a label
				label = document.createElement("label");
				label.appendChild(item);
				item = label;

				return item;
				break;
			
			case DisplayMode.ACCORDION:
				var accordion = document.createElement("div");
				accordion.innerHTML = this.content;
				
				//Warning: if you have a class='children' element, you should have a label tag, too.
				var label = accordion.getElementsByTagName("label")[0];
				if (!label && this.hasCheckbox) {
					//If there's no label inside the accordion, wrap the entire thing with a label (before we add the 'children' element).
					label = document.createElement("label");
					accordion = document.createElement("div");
					label.innerHTML = this.content; //Don't include the extra div (which would put the text on a different line from the label)
					accordion.appendChild(label);
					//TODO: Check for a class='children' inside the label here, move it to after the label, and then remove the above warning.
				}
				
				var childContainer = accordion.getElementsByClassName("children")[0];
				if (!childContainer) { //If there isn't a container specified by the user, just append one.
					childContainer = document.createElement("div");
					childContainer.classList.add("children");
					accordion.appendChild(childContainer);
				}
				
				console.assert(this.children.length > 0, "Accordion nodes should have children, but this one does not; KnowledgeNode ID " + this.id);
				for (var x = 0; x < this.children.length; x++) {
					console.assert(this.children[x].displayMode != DisplayMode.POP, "Accordion nodes should not have Pop children; KnowledgeNode ID " + this.id);
					childContainer.appendChild(this.children[x].toNode(depth + 1));
				}
				
				//Accordion toggle behavior
				//Make sure the first node is an element
				//if (accordion.firstChild != accordion.children[0]) {
				//	var span = document.createElement("span");
				//	span.appendChild(accordion.firstChild); //Move the text into the span
				//	accordion.insertBefore(span, accordion.firstChild); //Move the span into the accordion
				//}
				//accordion.children[0].onclick = (event) => toggleAccordion(event);
				
				//Checkbox
				if (this.hasCheckbox) label.insertBefore(this.makeCheckbox(), label.firstChild);
				
				//Accordion expansion
				var arrow = document.createElement("span");
				arrow.classList.add("arrow");
				arrow.tabIndex = 0; //Allow the user to focus on the arrow (in source order). Accessibility!
				arrow.onclick = (event) => toggleAccordion(event);
				
				//Make sure pressing space and pressing enter result in the same thing as a click
				arrow.onkeydown = (event) => {
					if (event.key == "Enter" || event.key == " ") {
						arrow.click();
						event.preventDefault();
					}
				};
				
				accordion.insertBefore(arrow, accordion.firstChild);
				
				accordion.classList.add("accordion");
				accordion.classList.add("collapsed"); //TODO: Might want to expand to show all not-already-checked nodes. Maybe not. Maybe there should be an "expand children" button. Dunno.
				
				//If there's a header element inside but no checkbox, make the header element also expand/collapse the accordion.
				if (!this.hasCheckbox) {
					var header = accordion.getElementsByTagName("h2");
					if (header.length) {
						arrow.appendChild(header[0]); //Also removes it from its previous location
						header[0].appendChild(this.makePermalink());
					}
				} else if (label) {
					label.appendChild(this.makePermalink());
				}

				if (!this.permalinkTarget) this.permalinkTarget = accordion;
				return accordion;
				break;
			
			case DisplayMode.POP:
				console.assert(this.children.length == 0, "Pop nodes should not have children; KnowledgeNode ID " + this.id);
				
				var pop = document.createElement("a");
				pop.innerText = "?";
				pop.classList.add("pop-button");
				if (this.checked) pop.classList.add("checked-pop-button");
				pop.onclick = pop.onmouseenter = (event) => {
					this.popOpen(event);
					event.stopPropagation(); //Otherwise, the click event passes on to the label, which checks or unchecks the parent item's checkbox.
					return false;
				}
				pop.tabIndex = 0; //Allow the user to focus on the pseudo-link (in source order). Accessibility!
				//TODO: I think Safari won't let you click on an 'a' tag without a href attribute. Fix that.
				
				//Make sure pressing space and pressing enter result in the same thing as a click
				pop.onkeydown = (event) => {
					if (event.key == "Enter" || event.key == " ") {
						pop.click();
						event.preventDefault();
					}
				};
				
				if (!this.permalinkTarget) this.permalinkTarget = pop;
				return pop;
				break;
			
		}
	}
	
	/**
	 * Response to the checkbox being toggled directly by the user; sets the internal state of this checkbox and all its descendants
	 * @param {bool} checked True if the checkbox was just checked; false if it was just unchecked
	 */
	onToggleByUser(checked) {
		//Save the time it was checked or nullify if it was unchecked.
		this.setChecked(checked ? new Date() : null);
		
		try {
			saveToLocalStorage();
			KnowledgeNode.changedSinceSave = false;
		} catch {
			//Warn user that localStorage doesn't work
			if (!KnowledgeNode.warned) {
				var notice = prepareNotice("Saving your progress in the browser's localStorage failed. Please download your progress file at your leisure.", 5000);
				notice.style.top = notice.style.left = "5px";
				notice.style.backgroundColor = "#fca";
				KnowledgeNode.warned = true;
			}
			KnowledgeNode.changedSinceSave = true;
		}
	}
	
	/**
	 * Set the state of this node and all its checkboxes. For loading a saved file (since the DOM already exists by then).
	 * @param {Date} checked A valid Date if the checkbox should be set to checked; null otherwise
	 */
	setChecked(checked) {
		console.assert(checked == null || checked instanceof Date);
		this.checked = checked;
		for (var x = 0; x < this.domCheckboxes.length; x++) {
			this.domCheckboxes[x].checked = checked;
		}
		
		//Add/remove "checked-pop-button" class on POP items when they get checked/unchecked
		if (this.displayMode == DisplayMode.POP) this.permalinkTarget.classList.toggle("checked-pop-button", checked);
	}
	
	/**
	 * Create a DOM 'a' tag that gives a permalink to this KnowledgeNode
	 */
	makePermalink() {
		var permalink = document.createElement("a");
		permalink.classList.add("permalink");
		permalink.innerHTML = "&#128279;";
		permalink.href = "#" + this.id; //In case they right-click to copy it
		permalink.onclick = (event) => {
			var area = document.createElement("textarea");
			area.innerText = permalink.href;
			event.target.appendChild(area); //to avoid scrolling, put it where the cursor is
			area.focus();
			area.select();
			document.execCommand("copy");
			area.remove();
			
			var notice = prepareNotice("Link copied!", 1500);
			
			//Same positioning code as the Pop panel
			notice.style.left = Math.max(0, Math.min(event.target.offsetLeft - document.body.scrollLeft - 10 /*notice left padding*/, document.body.clientWidth - notice.offsetWidth)) + "px";
			notice.style.top = Math.max(0, Math.min(event.target.offsetTop - document.body.scrollTop - 10 /*notice top padding*/, document.body.clientHeight - notice.offsetHeight)) + "px";
			
			event.stopPropagation();
			return false;
		};
		
		permalink.onkeydown = (event) => {
			if (event.key == "Enter" || event.key == " ") {
				permalink.click();
				event.stopPropagation();
				event.preventDefault();
			}
		};
		
		return permalink;
	}
	
	/**
	 * Create a DOM input node as a checkbox for this KnowledgeNode. The checkbox's initial state depends on this.checked.
	 */
	makeCheckbox() {
		console.assert(this.hasCheckbox, "Should not be calling makeCheckbox if hasCheckbox is false; KnowledgeNode ID " + this.id);
	
		var chk = document.createElement("input");
		chk.type = "checkbox";
		chk.checked = this.checked;
		chk.onclick = () => { this.onToggleByUser(chk.checked) };
		
		//Keep track of this checkbox internally for synchronization
		this.domCheckboxes.push(chk);
		
		return chk;
	}
	
	/**
	 * Create DOM elements to represent the content (and checkbox) for this Pop-type KnowledgeNode.
	 */
	popOpen(event) {
		//Make a pop-panel and pop-backdrop on the body.
		var backdrop = document.createElement("div");
		backdrop.classList.add("pop-backdrop");

		var panel = document.createElement("div");
		panel.classList.add("pop-panel");
		panel.innerHTML = this.content;

		if (this.hasCheckbox) {
			var checkbox = this.makeCheckbox();
			panel.insertBefore(checkbox, panel.firstChild);
		}

		document.body.appendChild(backdrop);
		document.body.appendChild(panel);
		
		if (this.hasCheckbox) checkbox.focus(); //In case you're using keyboard navigation

		panel.onmouseleave = backdrop.onclick = () => {
			//Remove the checkbox from our tracking list
			if (this.hasCheckbox) this.domCheckboxes.splice(this.domCheckboxes.indexOf(checkbox), 1);
			panel.remove();
			backdrop.remove();
		};
		
		//Let the escape key close the pop panel
		panel.onkeydown = (innerEvent) => {
			if (innerEvent.key == "Escape") {
				backdrop.click();
				event.target.focus(); //Put the user's focus back where it was before (for keyboard navigation)
			}
		};

		//Make sure the width is no greater than 8x the initial height (for decent proportioning--the final aspect ratio will be much less than 8:1) and no greater than the width of the viewport.
		panel.style.width = Math.min(panel.offsetHeight * 8, Math.min(document.body.clientWidth, panel.offsetWidth)) + "px";
		panel.style.left = Math.max(0, Math.min(event.target.offsetLeft - document.body.scrollLeft - 10 /*pop-panel left padding*/, document.body.clientWidth - panel.offsetWidth)) + "px";
		panel.style.top = Math.max(0, Math.min(event.target.offsetTop - document.body.scrollTop - 10 /*pop-panel top padding*/, document.body.clientHeight - panel.offsetHeight)) + "px";
	}
}
KnowledgeNode.allNodes = [];

function toggleAccordion(event) {
	var parent = event.target.parentNode;
	//Find the accordion parent (currently only needed for top-level, checkbox-free accordions)
	while (!parent.classList.contains("accordion")) parent = parent.parentNode;
	parent.classList.toggle("collapsed");
}

var topNodes = []; //Accessible for easier development.
//Startup code
document.body.onload = function() {
	//Declarations for reused KnowledgeNodes
	var creatingAwarenessPop;
	//Load items' checked-on dates from localStorage before creating any KnowledgeNodes.
	loadFromLocalStorage();
	
	//Use this because the top-level categories should have the same format, and their IDs do not matter.
	var topLevelCategories = 0;
	function makeTopLevelCategoryNode(name, children) {
		return new KnowledgeNode(topLevelCategories++, DisplayMode.ACCORDION, "<label><h2>" + name + "</h2></label><section class='children'></section>", children, false);
	}
	
	topNodes = [
		makeTopLevelCategoryNode("Attitude", [
			new KnowledgeNode(126, DisplayMode.ITEM, "Practice pragmatism, not dogmatism. <a data-index='0'></a>", [
				new KnowledgeNode(127, DisplayMode.POP, "Dogmatism means you see concepts as rules to be followed without context. A pragmatist considers the pros and cons of each approach in-context and seeks the best answer for each specific situation."),
			])
		]),
		makeTopLevelCategoryNode("Job Hunting", [
			new KnowledgeNode(129, DisplayMode.ITEM, "Technologies and years of experience are usually the main hiring criteria. <a data-index='0'></a>", [
				new KnowledgeNode(150, DisplayMode.POP, "<a href='https://www.joelonsoftware.com/2006/09/08/sorting-resumes-2/'>Sorting Resumes</a>"),
			]),
			new KnowledgeNode(151, DisplayMode.ITEM, "Experience with uncommon technologies/languages like COBOL may offer fewer opportunities but significantly higher pay."),
		]),
		makeTopLevelCategoryNode("Requirements", [
			new KnowledgeNode(130, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Planning", [
			new KnowledgeNode(131, DisplayMode.ACCORDION, "Automate everything that reasonably can be automated.", [
				new KnowledgeNode(140, DisplayMode.ITEM, "If it takes more than two actions to perform a repeated task, it should probably be automated."),
				new KnowledgeNode(141, DisplayMode.ITEM, "Automation scripts also simultaneously act as documentation and reduce the need for humans to look at documentation."),
				new KnowledgeNode(142, DisplayMode.ITEM, "If it takes more than two actions to perform a repeated task, it should probably be automated."),
				new KnowledgeNode(143, DisplayMode.ITEM, "Automating infrequent tasks is roughly as important as automating frequent ones, because humans forget less frequent things more easily."),
				new KnowledgeNode(144, DisplayMode.ITEM, "Automate pulling the code, tools, and dependencies to help new team members get involved."),
				new KnowledgeNode(145, DisplayMode.ITEM, "Automate code formatting to maintain consistent style and avoid merge conflicts caused by reformatting."),
				new KnowledgeNode(146, DisplayMode.ITEM, "Automate static analysis to maintain code quality."),
				new KnowledgeNode(147, DisplayMode.ITEM, "Automate the build process."),
				new KnowledgeNode(148, DisplayMode.ITEM, "Automate test execution to reduce broken commits and repeat bugs."),
				new KnowledgeNode(149, DisplayMode.ITEM, "Automate publishing, including packaging of resources if not done during the build."),
			]),
			new KnowledgeNode(152, DisplayMode.ACCORDION, "All decisions come with trade-offs.", [
				new KnowledgeNode(153, DisplayMode.ITEM, "Ease of coding often has an inverse relationship with runtime efficiency. <a data-index='0'></a> <a data-index='1'></a>", [
					new KnowledgeNode(157, DisplayMode.POP, "Garbage collection, exceptions, preemptive scheduling, and even parallel processing have their own costs."),
					new KnowledgeNode(158, DisplayMode.POP, "Benchmark rather than speculating whenever efficiency is a concern."),
				]),
				new KnowledgeNode(154, DisplayMode.ITEM, "Most technologies don't advertise their potentially detrimental aspects."),
				new KnowledgeNode(155, DisplayMode.ITEM, "Things that improve maintainability (or any software quality metric) in one way can also hurt it worse in another way. <a data-index='0'></a>", [
					new KnowledgeNode(156, DisplayMode.POP, "<a href='https://blogs.msdn.microsoft.com/gabriel_morgan/2007/03/20/implementing-system-quality-attributes/'>Implementing System Quality Attributes</a>"),
				]),
			]),
		]),
		makeTopLevelCategoryNode("Leadership", [
			new KnowledgeNode(101, DisplayMode.ITEM, "Consider the human feelings of those under your lead, but do not forget the project priorities. <a data-index='0'></a>", [
				new KnowledgeNode(128, DisplayMode.POP, "Remember the rest of the team when making a decision on behalf of an individual. Some get jealous easily, and it may be seen as favoritism if one individual demands a lot of consideration."),
			]),
			new KnowledgeNode(118, DisplayMode.ITEM, "Knowing how to lead the team helps you be a part of the team."),
			new KnowledgeNode(119, DisplayMode.ITEM, "Praise others' creativity or work ethic or at least show appreciation for their efforts when you're tempted to criticize their work."),
			new KnowledgeNode(120, DisplayMode.ITEM, "You can memorize your own set of management phrases and praises. <a data-index='0'></a> <a data-index='1'></a>", [
				new KnowledgeNode(121, DisplayMode.POP, "Example: &quot;That's an excellent idea. Like all ideas, however, it does have cons--can you tell us about the negatives and why you believe this idea will work well despite them?&quot;"), //TODO: Use a new type of node for these
				new KnowledgeNode(122, DisplayMode.POP, "Example: &quot;If you would, please teach me and help me understand this,&quot; instead of &quot;That doesn't make sense.&quot;"),
			]),
			new KnowledgeNode(139, DisplayMode.ITEM, "Stand up when speaking to a group. <a data-index='0'></a>", [
				new KnowledgeNode(159, DisplayMode.POP, "<a href='https://dl.acm.org/citation.cfm?id=1550898'>97 Things Every Software Architect Should Know</a>")
			]),
		], false), 
		makeTopLevelCategoryNode("Teamwork", [
			new KnowledgeNode(113, DisplayMode.ACCORDION, "Software development is as much dealing with human psychology, such as preventing mistakes, as it is writing software.", [
				new KnowledgeNode(123, DisplayMode.ITEM, "Development processes are designed to reduce human mistakes."),
				new KnowledgeNode(124, DisplayMode.ITEM, "Automation is designed to prevent human mistakes."),
				new KnowledgeNode(125, DisplayMode.ITEM, "Type safety and other guarantees (like those central to the design philosophy of languages like Rust and Go) identify mistakes sooner."),
			]),
			new KnowledgeNode(100, DisplayMode.ACCORDION, "Be slow to cast blame.", [
				new KnowledgeNode(104, DisplayMode.ITEM, "Don't blame the user before blaming the design <a data-index='0'></a>.", [
					new KnowledgeNode(105, DisplayMode.POP, "<a href='https://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C'>The Design of Everyday Things</a>")]),
				new KnowledgeNode(106, DisplayMode.ITEM, "Admit your mistakes for the sake of process improvement and learning <a data-index='0'></a>.", [
					creatingAwarenessPop = new KnowledgeNode(107, DisplayMode.POP, "<a href='https://accu.org/index.php/journals/1436'>Creating Awareness</a>")]),
				new KnowledgeNode(108, DisplayMode.ITEM, "Even if you cast blame only to inject humor, ensure that you also quickly follow up with sharing the blame or pointing out that mistakes can happen to anyone, because your jokes will be taken personally and can quickly lead to a hostile environment."),
			]),
			new KnowledgeNode(109, DisplayMode.ACCORDION, "Keep a document of lessons learned.", [
				new KnowledgeNode(110, DisplayMode.ITEM, "Log everything you can, because without data, proper studies are impossible. <a data-index='0'></a>", [creatingAwarenessPop]),
				new KnowledgeNode(111, DisplayMode.ITEM, "Checklists and 'lessons learned' documents help because schools/authors/humans only have so much time/energy/memory and so much they can spontaneously recall or teach you about."),
				new KnowledgeNode(112, DisplayMode.ITEM, "A good document of lessons learned could rapidly teach a young developer lessons that they otherwise may never learn or may learn only after many years of experience, as well as reminding you of lessons you once learned and may have forgotten."),
			]),
			new KnowledgeNode(114, DisplayMode.ITEM, "A good developer is polite and considerate in the line of duty. <a data-index='0'></a>", [
				new KnowledgeNode(115, DisplayMode.POP, "Political correctness is intended to reduce the unnecessary involvement of negative emotions, which block progress.") //Needs examples
			]),
			new KnowledgeNode(116, DisplayMode.ITEM, "If your manager doesn't value the team's input, make them think it was their idea by asking them questions leading to it."), //Needs examples
			new KnowledgeNode(117, DisplayMode.ITEM, "Customers, stakeholders, and managers assign different weights to their values (such as cost and efficiency); you may have to search for benefits to your idea from different perspectives in order for it to be accepted."), //Needs examples
		]), 
		makeTopLevelCategoryNode("Architecture", [
			new KnowledgeNode(132, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Design", [
			new KnowledgeNode(102, DisplayMode.ITEM, "Read a book <a data-index='0'></a> for best results. (This is a temporary item until the category can be fleshed out.)", [
				new KnowledgeNode(103, DisplayMode.POP, "I recommend <a href='https://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C'>The Design of Everyday Things</a>."),
			]),
		]), 
		makeTopLevelCategoryNode("Legal", [
			new KnowledgeNode(133, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Programming", [
			new KnowledgeNode(134, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Documenting", [
			new KnowledgeNode(135, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Optimizing", [
			new KnowledgeNode(136, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Testing", [
			new KnowledgeNode(137, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Publishing", [
			new KnowledgeNode(138, DisplayMode.ITEM, "To-do"),
		]),
	];
	
	//Add the major section nodes to the body
	var masterNode = document.getElementById("masternode");
	for (var x = 0; x < topNodes.length; x++) masterNode.appendChild(topNodes[x].toNode());
	
	//Inform developers what the current top KnowledgeNode ID is.
	var topFoundId = determineTopId();
	console.log("Current highest KnowledgeNode ID: " + topFoundId);
	console.assert(topFoundId <= highestUsedId, "Please update highestUsedId.");
	
	//Potentially scroll to a KnowledgeNode
	if (window.location.hash) { //Make sure the hash is present
		var id = parseInt(window.location.hash.substr(1));
		if (!isNaN(id)) { //Make sure the parameter is numeric
			goToNode(id);
		}
	}
};

//Call this from your browser's dev tools to keep track of the highest ID: determineTopId()
//(IDs should not be changed or reused, as it would break the users' save data. This is to help you find the newest ID in case you forgot.)
function determineTopId() {
	return KnowledgeNode.allNodes.length - 1; //Assumes that allNodes remains an array and has its elements directly set
}

/**
 * Get a list of objects with 'id' and 'date' corresponding to the KnowledgeNodes that are checked
 */
function getCheckedItems() {
	var checkedItems = [];
	for (var x = 0; x < KnowledgeNode.allNodes.length; x++) {
		if (KnowledgeNode.allNodes[x] && KnowledgeNode.allNodes[x].checked) 
			checkedItems.push({ id: x, date: KnowledgeNode.allNodes[x].checked });
	}
	return checkedItems;
}

/**
 * Save the IDs and checked-on dates of checked nodes to localStorage.
 * @throws {DOMException} (see documentation for localStorage.setItem)
 */
function saveToLocalStorage() {
	var idsAndDates = getCheckedItems();
	localStorage.setItem("CheckedItems", JSON.stringify(idsAndDates));
}

/**
 * Load the IDs and checked-on dates of checked nodes from localStorage.
 * Only call this before you create any KnowledgeNodes.
 */
function loadFromLocalStorage() {
	var idsAndDates = JSON.parse(localStorage.getItem("CheckedItems") || "[]");
	//Put the dates into the allNodes list.
	for (var x = 0; x < idsAndDates.length; x++) {
		KnowledgeNode.allNodes[idsAndDates[x].id] = new Date(idsAndDates[x].date);
	}
}

window.onbeforeunload = function(event) { //TODO: This doesn't occur if you hit refresh (in Chrome). Look for other events that may help; you want to just save every time the user touches a checkbox, but they may still need reminded to save their file locally.
	try {
		saveToLocalStorage();
	} catch {
		//We'll have to get a little intrusive for this exceptional case.
		//If we don't stop to ask them, they would either have to lose their changes or be forced to download a file without being informed of the reason.
		if (KnowledgeNode.changedSinceSave && confirm("Saving your progress to localStorage failed. Save it as a file before leaving?")) {
			saveProgressAsFile();
		}
	}
};

function saveProgressAsFile() {
	var idsAndDates = getCheckedItems();
	idsAndDates.title = "FIPBYBSDS";
	saveObject(idsAndDates);
	
	//We can't know if the download succeeded, but it would be obnoxious if we assumed that it did not.
	KnowledgeNode.changedSinceSave = false;
}

function dragOver(event) {
	event.preventDefault();
}

function dragEnter(event) {
	//Only show the drop zone if the user is dragging files into the window
	//We need getAsFile() support (Safari doesn't have it) so only react if it's defined
	if ([...event.dataTransfer.items].some(p => p.kind == "file") && DataTransferItem.prototype.getAsFile) {
		setDropZoneVisible(true);
	}
}

function dropInProgressFile(event) {
	//Convert the DataTransferItem
	loadProgressFile([...event.dataTransfer.items].filter(p => p.kind == "file").map(p => p.getAsFile()));
	
	setDropZoneVisible(false);
	
	//Don't let the browser try loading the file in its own way
	event.preventDefault();
	event.stopPropagation();
}

function setDropZoneVisible(isVisible) {
	document.getElementById("dropzone").style.display = isVisible ? "" : "none";
}

function loadProgressFile(files) {
	//TODO: Consider a check/warning because if they had progress in localStorage already, it'll be overwritten upon loading progress from a file.

	if (files.length == 1) {
		if (files[0].size > 500000) { //Check for reasonable size
			alert("This file appears to be too large to have been saved from this application.");
			return;
		}
		
		var reader = new FileReader();
		reader.onload = (file) => {
			var data = JSON.parse(file.target.result);
			//It should be an array, and the first element shouldn't have an ID of 0 (that one isn't checkable anyway) or an empty date.
			if (!data.length || !data[0].id || !data[0].date) {
				alert("This file does not appear to have originated from this application.");
				return;
			}
			
			//For a full reload, we'll clear out the existing nodes' checked state first.
			for (var x = 0; x < KnowledgeNode.allNodes.length; x++) {
				if (KnowledgeNode.allNodes[x]) {
					KnowledgeNode.allNodes[x].setChecked(null);
				}
			}
			
			for (var x = 0; x < data.length; x++) {
				if (KnowledgeNode.allNodes[data[x].id]) {
					KnowledgeNode.allNodes[data[x].id].setChecked(new Date(data[x].date));
				} else {
					console.log("Unknown ID " + data[x].id + "; this item may have been removed.");
				}
			}
		};
		reader.readAsText(files[0]);
	} else if (files.length > 1) {
		alert("Please only drop in one file.");
	} //if files.length is 0, there's nothing to do, but it doesn't necessitate a message.
}

/**
 * Save the given object as a JSON file. If it has a title or name property, that will be used as the filename.
 * (Copied from a character build planner project.)
 * @param {object} obj Any JSON.stringify-capable object (which will be saved as a file)
 */
function saveObject(obj) {
	if (window.navigator && window.navigator.msSaveOrOpenBlob) {
		window.navigator.msSaveOrOpenBlob(new Blob([JSON.stringify(obj)], 'application/json'));
	} else {
		document.body.insertAdjacentHTML("beforeend", "<a style='display:none' href='data:text/plain;charset=utf-8," + encodeURIComponent(JSON.stringify(obj)) + "' download='" + (obj.title || obj.name || "build") + ".json' id='dllink'></a>");
		var l = document.getElementById("dllink");
		l.click();
		l.remove();
	}
}

/**
 * Unfold and scroll to the specified node or ID. Also highlight the node briefly.
 * @param {KnowledgeNode or the ID of a KnowledgeNode} nodeOrId Node or ID of a node to navigate to
 */
function goToNode(nodeOrId) {
	if (!isNaN(nodeOrId)) nodeOrId = KnowledgeNode.allNodes[nodeOrId];
	
	//Inform user if ID is invalid
	if (!(nodeOrId instanceof KnowledgeNode)) {
		alert("The specified knowledge item does not exist.");
		return;
	}
	
	//Expand all its parent accordions and then scroll to it
	//Note: this should find the *first* appearance of the node from the top of the page
	var node = nodeOrId.permalinkTarget;
	while (node.id != "masternode") {
		node = node.parentNode;
		if (node.classList.contains("collapsed")) {
			node.classList.remove("collapsed");
		}
	}
	
	//Find the first label or paragraph parent or div and highlight it temporarily
	node = nodeOrId.permalinkTarget;
	while (node.nodeName != "LABEL" && node.nodeName != "P" && node.nodeName != "DIV") {
		node = node.parentNode;
	}
	node.style.backgroundColor = "#fbf";
	node.style.transition = "background-color 1000ms";
	//Note: it doesn't matter much in this application, but this does introduce concurrency issues.
	setTimeout(() => {
		node.style.backgroundColor = "";
		//Turn transition back off a second later
		setTimeout(() => {
			node.style.transition = "";
		}, 1000);
	}, 1500);

	nodeOrId.permalinkTarget.scrollIntoView();
	
	//TODO: If it's a Pop-type node or top-level category, I'll need to come up with another way to locate it.
}

/**
 * Unfold and scroll to the node with the most recent checked-on date. Also highlight the node briefly.
 */
function goToLastChecked() {
	var lastCheckedNode = null;
	
	//Find the most recently checked node
	for (var x = 0; x < KnowledgeNode.allNodes.length; x++) {
		if (KnowledgeNode.allNodes[x] && KnowledgeNode.allNodes[x].checked && KnowledgeNode.allNodes[x].domCheckboxes.length && //TODO: Once you pick a way to find Pop-type nodes, drop the domCheckboxes condition
		(lastCheckedNode == null || KnowledgeNode.allNodes[x].checked > lastCheckedNode.checked)) {
			lastCheckedNode = KnowledgeNode.allNodes[x];
		}
	}
	
	if (lastCheckedNode) {
		goToNode(lastCheckedNode);
	} else alert("No items have been checked.");
}

/**
 * Create a notice with the given message (no HTML) and set it to fade away after the given delay.
 * Note: you'll have to set the position and/or size as desired after calling this.
 * @param {string} message Text to display (no HTML)
 * @param {int} delay Milliseconds to display the message before beginning to fade out
 * @returns the generated notice DOM element
 */
function prepareNotice(message, delay) {
	var notice = document.createElement("div");
	notice.innerText = message;
	notice.classList.add("notice");
	document.body.appendChild(notice);
	
	//Fade out and remove after a moment
	setTimeout(() => {
		notice.style.opacity = "0";
		setTimeout(() => {
			notice.remove();
		}, 1000);
	}, delay);
	
	return notice;
}

//Updating this project:
//Update this constant when you add a KnowledgeNode (for the sake of the next person who wants to add KnowledgeNodes or if someone removes the most recently added one that was published):
const highestUsedId = 159;
//Nodes should identify facts, ideas, principles, "best practices," shortcomings, and reasonable alteratives (aiding in pragmatism).
//Keep reasoning (if more than a few words), more esoteric knowledge (language-, domain-, or algorithm-specific), and examples in out-of-the-way places (like Pop items) while remembering that they may be independently displayed.
//Due to the vast array of languages, domains, and algorithms in existence, forks of this project (with none of the original KnowledgeNodes) may be necessary for anything that doesn't generalize well.
//Top-level categories don't have to make statements or suggestions, but others should do so to the extent feasible.
//References you have to pay for should always be listed last. Otherwise, it would be preferable to list the shortest ones first.
//Try to reduce repeat items by combining similar ones with a phrasing that allows them to apply to both, and then use the same item in both places.

/*
-----------------------------------
Knowledge items that need formatted
-----------------------------------

Being a great developer requires considering the human aspects of yourself, your teammates, your manager, and the users.
 
Deflect subtly and play the politics game, keeping the customer's best interests in mind.

Maintaining a healthy body and mind is paramount to being a good developer, and that requires sleep, exercise, nutrition, and ergonomics. Being a considerate person is extremely important, too (see assertion #1 above).
Guidelines, principles, and best practices are not rules; they're not perfect and are not meant to be the best answer in every situation. What's always best is to weigh your options in context. The same applies for tools, technologies, and methodologies. Additionally, they're very hard to study, so you can't be sure how much they help solely based on speculation of their pros and cons [https://accu.org/index.php/journals/1547]. [Some discussion of the dubious benefits of pair programming: https://accu.org/index.php/journals/1983] [Some discussion of the difficulties involved in agile: https://accu.org/index.php/journals/2003]
Best practices and principles include KISS [Keep It Stupid-Simple], SOLID [Single Responsibility; Open/Closed; Liskov Substitution; Interface Segregation; Dependency Inversion: https://accu.org/index.php/journals/1957], DRY [Don't Repeat Yourself] [Cases to ignore DRY: https://accu.org/index.php/journals/2662], consistency, loose coupling (and dependency injection), leaky abstractions [https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/], logic and documentation locality... Facts include "nothing is as simple as it seems." [https://www.joelonsoftware.com/2002/03/04/nothing-is-as-simple-as-it-seems/]
New technologies give you new ways of thinking, so try out a lot of languages and libraries. MATLAB/OCTAVE work with vector operations (SIMD--single instruction multiple data) so you often don't have to loop (see also: LINQ, map, reduce); functional languages like Haskell make you rely less on the program state and more on passing data around; declarative languages like VHDL give you a chance to break out of the sequence mindset.
Read some books (The Design of Everyday Things Revised and Expanded Edition, https://github.com/accu-org/essential-books/wiki ), and blogs (ITHare.com, GamaSutra, ACCU.org journals, https://devblogs.microsoft.com/oldnewthing/, maybe JoelOnSoftware.com) at different points in your life, not just technology-specific tutorials and articles.
Make improvement your responsibility. If you join a group and see that they have no overview-level documentation or list of common misunderstandings or anything to help newcomers get up to speed, it'll be helpful to everyone if you choose to be the one to create it.
Avoid interruptions. Every interruption resets your working memory, leading to a loss of 15-30 minutes of productivity.
Triple your initial estimates [http://programs.clearerthinking.org/how_well_anchored_are_your_estimates.html] or estimate with a confidence interval [https://accu.org/index.php/journals/1836]. Only make estimates for your own projects [https://www.joelonsoftware.com/2007/10/26/evidence-based-scheduling/], and break down projects that are more than a few days long to estimate them better. It's much easier to estimate how long something will take once you've actually thought about the challenges involved, but your estimates still need padded for bugs, interruptions, and test time.
Don't try to get even close to 100% automated test coverage in a non-safety-critical application. [http://ithare.com/too-much-unit-testing-is-detrimental-for-code-quality/] [http://ithare.com/testing-my-personal-take-on-testing-including-unit-testing-and-atddbdd/]
When writing code, especially if you don't have a formal design prepared in advance, write to-do comments explaining the process. You can take off the "TODO" as you complete these, and they become documentation of the intention behind sections of your code. This also serves as a guide and helps if you get interrupted or forget what you were doing.
Brainstorming consists of coming up with ideas and leaving their evaluation for later. [https://www.managers.org.uk/~/media/Files/Campus%20CMI/Checklists%20PDP/Brainstorming.ashx]
When you find a need to optimize your code (which requires first benchmarking to identify the slowest parts), first try reducing the run time complexity of the algorithms, such as changing a search into a hash-based lookup. If that proves insufficient, you may have to sacrifice clean, maintainable code for optimization. Compilers, particularly those for more mature programming languages, are very smart and capable of optimizing in a lot of ways, so you probably won't get anything out of simple changes [http://ithare.com/the-importance-of-back-of-envelope-estimates/]. However, compilers do not have problem domain knowledge and are restricted from performing some optimizations due to their general-purpose nature. In some cases, changing a class to a struct may result in a speed increase because it can increase cache locality and reduce redirection. Compilers for less mature languages may be unable to perform common optimizations like loop interchange and tail recursion. [https://en.wikipedia.org/wiki/Optimizing_compiler] [http://ithare.com/optimizing-big-number-arithmetic-without-sse/]
Fix bugs before implementing new features. Perform a proper root-cause analysis. Bugs can have hard-to-realize underlying causes that could affect new features. Their effects on other existing features could also go unnoticed.
No matter how minor you think a change is, test again after making it.
If someone questions a piece of code, add a comment addressing their concern (or rephrase an existing comment if it helps), because chances are good someone else will question it for the same reason eventually.
Remember your potential numeric ranges and font sizes when designing visuals like pie charts (e.g. how can you fit a label on a 1% sliver?) and raw text displays (word wrap? Word break? Scrolling?).
**Metrics
**Requirements elicitation (ambiguity is the greatest evil), requirements documents, requirements tracking
**Job hunting
**Anti-patterns
**Accessibility (colorblind, weak vision, blind, deaf)
**Globalization (language, encodings, decimals and commas, time zones, extra space for longer languages, right-to-left, fonts)
**Parallel execution
**Bonus: famous catch phrases. ITHare: Your Mileage May Vary. Lucian Radu Teodorescu (Do Repeat Yourself on ACCU): Don't Overdo It.
*/

//TODO: Go through the above items, check that they fit the project concept, and format them as code.
//TODO: Specify a standard for explanatory reasoning that doesn't qualify as a standalone knowledge item. (Basically, a Pop without a checkbox and with a "Why?" or "Examples" button instead of a "?" or whatever we settle on for references/external links to in-depth reasoning and examples.)
/*Wishlist:
Voting
Sorting
Filtering
Searching (due to the collapsible categories). If I show them in random order until there are over 100 user votes on the importance of each of the items, then I can be temporarily confident that it's not a popularity contest (say, because I had a fixed order, most people would only read the first few items) or chance ordering.
For better startup performance if we have a ton of nodes in accordions, we might just generate the child DOM when the accordion expands and maybe delete the child DOM when the accordion collapses.
*/
</script>
</body>
</html>

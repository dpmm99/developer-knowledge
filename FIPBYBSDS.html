<html>
<head>

<style>
h2 {
	margin-left: 8px;
	display: inline-block;
}

.children {
	margin-left: 1em;
}

.accordion > :not(.children) { /*Any direct descendants of the accordion container, except the children list, have the pointer*/
	/*cursor: pointer;*/
}

.accordion.collapsed .children {
	display: none;
}

.accordion > .arrow:before {
	cursor: pointer;
	content: '\25bc';
}
.accordion.collapsed > .arrow:before {
	cursor: pointer;
	content: '\25ba';
}

.pop-button {
	border-radius: 50%;
	background-color: #59f;
	color: #fff;
	text-decoration: none;
	padding: 0 5px;
}

.pop-button.checked-pop-button {
	background-color: #bbb;
}

.pop-panel {
	position: fixed;
	z-index: 2;
	background-color: #eee;
	border: 1px solid black;
	border-radius: 10px;
	padding: 8px;
	box-sizing: border-box;
}

.pop-backdrop {
	position: fixed;
	left: 0;
	top: 0;
	width: 100vw;
	height: 100vh;
	z-index: 1;
}

/*Experimental readability styling*/
.columnize {
	margin: 0 10%;
}
.columnize > * {
	display: inline;
}
@media (min-width: 50em) {
	.columnize {
		column-count: 2;
		margin: 0 5%;
	}
}
@media (min-width: 100em) {
	.columnize {
		column-count: 3;
		margin: 0;
	}
}
@media (min-width: 150em) {
	.columnize {
		column-count: 4;
	}
}
</style>
</head>
<body>

<h1>Facts, Ideas, and Principles for Becoming Your Best (Software Developer) Self</h1>
<div class="columnize">
<p>There is a vast amount of knowledge in the world, but much of it is sparsely distributed through wordy blog entries, articles, and books. The authors of these writings, as good authors tend to do, offer many examples and in-depth discussion of the concepts. However, most compositions cover a limited selection of concepts within the composition's already limited scope. This is not conducive to already knowledgeable individuals refreshing their knowledge or looking for realizations that have thus far escaped their judgment, nor does it function as guidance for novices seeking direction. As such, I offer this dense collection of a broad variety of facts, ideas, and principles in the hope that it can be a powerful, concise reference for experienced software developers (and related individuals) in their journey to become masters of all things surrounding their profession.</p>
<p>This page provides checkboxes to record your progress as you read individual items. The date and time of the moment you check each checkbox is saved in local storage. Because one can read through the items at any level or read the high-level items in one pass and the lower-level ones in another pass, consider each checkbox to apply only to the text directly adjacent to it.</p>
</div>
<section id="masternode"></section>

<script>
/**
 * Enum for possible appearances of a KnowledgeNode
 */
const DisplayMode = {
	/**
	 * Display as a single item. Can have POP children. <a> nodes with data-index are replaced by the child with the corresponding index.
	 */
	ITEM: "item",
	/**
	 * Display as a general description of an accordion list of items. Can have ITEM and ACCORDION children, which are placed in the node with the class "children".
	 * The first DOM element in the content is treated as the toggle button.
	 */
	ACCORDION: "accordion",
	/**
	 * Display as a tooltip. Cannot have children.
	 */
	POP: "pop"
}

const MAX_DEPTH = 4;

class KnowledgeNode {
	/**
	 * @param {int} id Permanent unique ID for this knowledge node. These should not change between updates, and there should be no duplicates.
	 * @param {DisplayMode} displayMode How this item should be displayed (options are "item", "accordion", "pop")
	 * @param {string} content HTML content to display
	 * @param {Array} children Array of KnowledgeNodes that this one contains (which would be checked if you check this node, and this node would be checked if you check all the children)
	 * @param {bool} hasCheckbox This item should have a checkbox (intended to be set to false for top-level categories which do not stand on their own as knowledge items)
	 */
	constructor(id, displayMode, content, children, hasCheckbox = true) {
		this.id = id;
		this.displayMode = displayMode;
		this.content = content;
		this.children = children || [];
		this.checked = KnowledgeNode.allNodes[this.id] || null; //Normally undefined, but we can fill that array with dates from localStorage when first loading the page, before creating any KnowledgeNodes.
		this.domCheckboxes = [];
		this.hasCheckbox = hasCheckbox;
		
		//Track all created nodes in a flat list. Ensure that no two nodes have the same ID.
		//Check either that it doesn't exist or that whatever exists there doesn't have a truthy "id" property (assuming Date won't ever have 'id')
		console.assert(!KnowledgeNode.allNodes[this.id] || !KnowledgeNode.allNodes[this.id].id, "Duplicate KnowledgeNode ID " + this.id);
		KnowledgeNode.allNodes[this.id] = this;
	}
	
	/**
	 * Creates and returns a DOM node for displaying this KnowledgeNode and all its descendants
	 * @param {int} depth Recursion depth (for debug assertion)
	 */
	toNode(depth = 0) {
		console.assert(depth <= MAX_DEPTH, "Exceeded max depth when constructing node for KnowledgeNode ID " + this.id);
		//Generate a DOM node depending on displayMode
		switch (this.displayMode) {
			case DisplayMode.ITEM:
				var item = document.createElement("p");
				item.innerHTML = this.content;
				
				var referencedChildren = this.children.map(p => 0); //Parallel to this.children; each element indicates the reference count for the child with the same index
				var pops = item.getElementsByTagName("a");
				for (var x = 0; x < pops.length; x++) {
					if (pops[x].dataset.index !== undefined) { //Check for data-index. If it has it, replace that element with the child whose index matches data-index.
						var idx = parseInt(pops[x].dataset.index);
						referencedChildren[idx]++; //Increment reference count for assertion
						console.assert(idx >= 0, "Negative or non-numeric data-index found ('" + pops[x].dataset.index + "') in KnowledgeNode ID " + this.id);
						console.assert(idx < this.children.length, "Found out-of-bounds data-index (" + idx + "; should be less than " + this.children.length + ") in KnowledgeNode ID " + this.id);
						
						pops[x].replaceWith(this.children[idx].toNode(depth + 1));
					} else console.assert(pops[x].href || pops[x].onclick, "Found an 'a' tag with neither a href nor an onclick event handler in KnowledgeNode ID " + this.id); //Probably a mistake
				}
				
				console.assert(referencedChildren.every(p => p > 0), "Unreferenced child " + referencedChildren.findIndex(p => p == 0) + " in KnowledgeNode ID " + this.id);
				console.assert(referencedChildren.every(p => p <= 1), "Repeat data-index " + referencedChildren.findIndex(p => p > 1) + " in KnowledgeNode ID " + this.id);
				
				//Checkbox
				item.insertBefore(this.makeCheckbox(), item.firstChild);
				
				//Wrap it all up in a label
				label = document.createElement("label");
				label.appendChild(item);
				item = label;

				return item;
				break;
			
			case DisplayMode.ACCORDION:
				var accordion = document.createElement("div");
				accordion.classList.add("accordion");
				accordion.classList.add("collapsed"); //TODO: Might want to expand to show all not-already-checked nodes. Maybe not. Maybe there should be an "expand children" button. Dunno.
				accordion.innerHTML = this.content;
				
				//Warning: if you have a class='children' element, you should have a label tag, too.
				var label = accordion.getElementsByTagName("label")[0];
				if (!label) {
					//If there's no label inside the accordion, wrap the entire thing with a label (before we add the 'children' element).
					label = document.createElement("label");
					label.appendChild(accordion);
					accordion = document.createElement("div");
					accordion.appendChild(label);
					//TODO: Check for a class='children' inside the label here, move it to after the label, and then remove the above warning.
				}
				
				var childContainer = accordion.getElementsByClassName("children")[0];
				if (!childContainer) { //If there isn't a container specified by the user, just append one.
					childContainer = document.createElement("div");
					childContainer.classList.add("children");
					accordion.appendChild(childContainer);
				}
				
				console.assert(this.children.length > 0, "Accordion nodes should have children, but this one does not; KnowledgeNode ID " + this.id);
				for (var x = 0; x < this.children.length; x++) {
					console.assert(this.children[x].displayMode != DisplayMode.POP, "Accordion nodes should not have Pop children; KnowledgeNode ID " + this.id);
					childContainer.appendChild(this.children[x].toNode(depth + 1));
				}
				
				//Accordion toggle behavior
				//Make sure the first node is an element
				//if (accordion.firstChild != accordion.children[0]) {
				//	var span = document.createElement("span");
				//	span.appendChild(accordion.firstChild); //Move the text into the span
				//	accordion.insertBefore(span, accordion.firstChild); //Move the span into the accordion
				//}
				//accordion.children[0].onclick = (event) => toggleAccordion(event);
				
				//Checkbox
				if (this.hasCheckbox) label.insertBefore(this.makeCheckbox(), label.firstChild);
				//TODO: If we don't have a checkbox, would it be right for clicking the text to make the accordion expand/collapse? It might introduce perceived internal consistency since clicking other items links to the checkbox... but without that feature, it's externally inconsistent.
				
				//Accordion expansion
				var arrow = document.createElement("span");
				arrow.classList.add("arrow");
				arrow.onclick = (event) => toggleAccordion(event);
				accordion.insertBefore(arrow, accordion.firstChild);
				
				return accordion;
				break;
			
			case DisplayMode.POP:
				console.assert(this.children.length == 0, "Pop nodes should not have children; KnowledgeNode ID " + this.id);
				
				var pop = document.createElement("a");
				pop.innerText = "?";
				pop.classList.add("pop-button");
				if (this.checked) pop.classList.add("checked-pop-button");
				pop.onclick = pop.onmouseenter = (event) => {
					this.popOpen(event);
					event.stopPropagation(); //Otherwise, the click event passes on to the label, which checks or unchecks the parent item's checkbox.
				}
				
				return pop;
				break;
			
		}
	}
	
	/**
	 * Response to the checkbox being toggled directly by the user; sets the internal state of this checkbox and all its descendants
	 * @param {bool} checked True if the checkbox was just checked; false if it was just unchecked
	 */
	onToggleByUser(checked) {
		this.checked = checked ? new Date() : null; //Save the time it was checked or nullify if it was unchecked.
		
		try {
			saveToLocalStorage();
		} catch {
			//TODO: unintrusively warn user that they're going to have to save their data manually
		}

		//TODO: Make all the checkboxes for this KnowledgeNode match the event.target DOM element. There will be repeat non-Pop nodes because mutually exclusive categories don't work as well as tags in reality.
		//TODO: Add/remove "checked-pop-button" class on POP items when they get checked/unchecked
	}
	
	/**
	 * Create a DOM input node as a checkbox for this KnowledgeNode. The checkbox's initial state depends on this.checked.
	 */
	makeCheckbox() {
		console.assert(this.hasCheckbox, "Should not be calling makeCheckbox if hasCheckbox is false; KnowledgeNode ID " + this.id);
	
		var chk = document.createElement("input");
		chk.type = "checkbox";
		chk.checked = this.checked;
		chk.onclick = () => { this.onToggleByUser(chk.checked) };
		
		//Keep track of this checkbox internally for synchronization
		this.domCheckboxes.push(chk);
		
		return chk;
	}
	
	/**
	 * Create DOM elements to represent the content (and checkbox) for this Pop-type KnowledgeNode.
	 */
	popOpen(event) {
		//Make a pop-panel and pop-backdrop on the body.
		var backdrop = document.createElement("div");
		backdrop.classList.add("pop-backdrop");

		var panel = document.createElement("div");
		panel.classList.add("pop-panel");
		panel.innerHTML = this.content;

		if (this.hasCheckbox) {
			var checkbox = this.makeCheckbox();
			panel.insertBefore(checkbox, panel.firstChild);
		}

		document.body.appendChild(backdrop);
		document.body.appendChild(panel);

		panel.onmouseleave = backdrop.onclick = () => {
			//Remove the checkbox from our tracking list
			if (this.hasCheckbox) this.domCheckboxes.splice(this.domCheckboxes.indexOf(checkbox), 1);
			panel.remove();
			backdrop.remove();
		};

		//Make sure the width is no greater than 8x the initial height (for decent proportioning--the final aspect ratio will be much less than 8:1) and no greater than the width of the viewport.
		panel.style.width = Math.min(panel.offsetHeight * 8, Math.min(document.body.clientWidth, panel.offsetWidth)) + "px";
		panel.style.left = Math.max(0, Math.min(event.target.offsetLeft - document.body.scrollLeft - 10 /*pop-panel left padding*/, document.body.clientWidth - panel.offsetWidth)) + "px";
		panel.style.top = Math.max(0, Math.min(event.target.offsetTop - document.body.scrollTop - 10 /*pop-panel top padding*/, document.body.clientHeight - panel.offsetHeight)) + "px";
	}
}
KnowledgeNode.allNodes = [];

function toggleAccordion(event) {
	event.target.parentNode.classList.toggle("collapsed");
}

var topNodes = []; //Accessible for easier development.
//Startup code
document.body.onload = function() {
	//Declarations for reused KnowledgeNodes
	var creatingAwarenessPop;
	//Load items' checked-on dates from localStorage before creating any KnowledgeNodes.
	loadFromLocalStorage();
	
	//Use this because the top-level categories should have the same format, and their IDs do not matter.
	var topLevelCategories = 0;
	function makeTopLevelCategoryNode(name, children) {
		return new KnowledgeNode(topLevelCategories++, DisplayMode.ACCORDION, "<label><h2>" + name + "</h2></label><section class='children'></section>", children, false);
	}
	
	topNodes = [
		makeTopLevelCategoryNode("Attitude", [
			new KnowledgeNode(126, DisplayMode.ITEM, "Practice pragmatism, not dogmatism. <a data-index='0'></a>", [
				new KnowledgeNode(127, DisplayMode.POP, "Dogmatism means you see concepts as rules to be followed without context. A pragmatist considers the pros and cons of each approach in-context and seeks the best answer for each specific situation."),
			])
		]),
		makeTopLevelCategoryNode("Job Hunting", [
			new KnowledgeNode(129, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Requirements", [
			new KnowledgeNode(130, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Planning", [
			new KnowledgeNode(131, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Leadership", [
			new KnowledgeNode(101, DisplayMode.ITEM, "Consider the human feelings of those under your lead, but do not forget the project priorities. <a data-index='0'></a>", [
				new KnowledgeNode(128, DisplayMode.POP, "Remember the rest of the team when making a decision on behalf of an individual. Some get jealous easily, and it may be seen as favoritism if one individual demands a lot of consideration."),
			]),
			new KnowledgeNode(118, DisplayMode.ITEM, "Knowing how to lead the team helps you be a part of the team."),
			new KnowledgeNode(119, DisplayMode.ITEM, "Praise others' creativity or work ethic or at least show appreciation for their efforts when you're tempted to criticize their work."),
			new KnowledgeNode(120, DisplayMode.ITEM, "You can memorize your own set of management phrases and praises. <a data-index='0'></a> <a data-index='1'></a>", [
				new KnowledgeNode(121, DisplayMode.POP, "Example: &quot;That's an excellent idea. Like all ideas, however, it does have cons--can you tell us about the negatives and why you believe this idea will work well despite them?&quot;"), //TODO: Use a new type of node for these
				new KnowledgeNode(122, DisplayMode.POP, "Example: &quot;If you would, please teach me and help me understand this,&quot; instead of &quot;That doesn't make sense.&quot;"),
			]),
			new KnowledgeNode(139, DisplayMode.ITEM, "Stand up when speaking to a group. <a data-index='0'></a>", [
				new KnowledgeNode(140, DisplayMode.POP, "<a href='https://dl.acm.org/citation.cfm?id=1550898'>97 Things Every Software Architect Should Know</a>")
			]),
		], false), 
		makeTopLevelCategoryNode("Teamwork", [
			new KnowledgeNode(113, DisplayMode.ACCORDION, "Software development is as much dealing with human psychology, such as preventing mistakes, as it is writing software.", [
				new KnowledgeNode(123, DisplayMode.ITEM, "Development processes are designed to reduce human mistakes."),
				new KnowledgeNode(124, DisplayMode.ITEM, "Automation is designed to prevent human mistakes."),
				new KnowledgeNode(125, DisplayMode.ITEM, "Type safety and other guarantees (like those central to the design philosophy of languages like Rust and Go) identify mistakes sooner."),
			]),
			new KnowledgeNode(100, DisplayMode.ACCORDION, "Be slow to cast blame.", [
				new KnowledgeNode(104, DisplayMode.ITEM, "Don't blame the user before blaming the design <a data-index='0'></a>.", [
					new KnowledgeNode(105, DisplayMode.POP, "<a href='https://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C'>The Design of Everyday Things</a>")]),
				new KnowledgeNode(106, DisplayMode.ITEM, "Admit your mistakes for the sake of process improvement and learning <a data-index='0'></a>.", [
					creatingAwarenessPop = new KnowledgeNode(107, DisplayMode.POP, "<a href='https://accu.org/index.php/journals/1436'>Creating Awareness</a>")]),
				new KnowledgeNode(108, DisplayMode.ITEM, "Even if you cast blame only to inject humor, ensure that you also quickly follow up with sharing the blame or pointing out that mistakes can happen to anyone, because your jokes will be taken personally and can quickly lead to a hostile environment."),
			]),
			new KnowledgeNode(109, DisplayMode.ACCORDION, "Keep a document of lessons learned.", [
				new KnowledgeNode(110, DisplayMode.ITEM, "Log everything you can, because without data, proper studies are impossible. <a data-index='0'></a>", [creatingAwarenessPop]),
				new KnowledgeNode(111, DisplayMode.ITEM, "Checklists and 'lessons learned' documents help because schools/authors/humans only have so much time/energy/memory and so much they can spontaneously recall or teach you about."),
				new KnowledgeNode(112, DisplayMode.ITEM, "A good document of lessons learned could rapidly teach a young developer lessons that they otherwise may never learn or may learn only after many years of experience, as well as reminding you of lessons you once learned and may have forgotten."),
			]),
			new KnowledgeNode(114, DisplayMode.ITEM, "A good developer is polite and considerate in the line of duty. <a data-index='0'></a>", [
				new KnowledgeNode(115, DisplayMode.POP, "Political correctness is intended to reduce the unnecessary involvement of negative emotions, which block progress.") //Needs examples
			]),
			new KnowledgeNode(116, DisplayMode.ITEM, "If your manager doesn't value the team's input, make them think it was their idea by asking them questions leading to it."), //Needs examples
			new KnowledgeNode(117, DisplayMode.ITEM, "Customers, stakeholders, and managers assign different weights to their values (such as cost and efficiency); you may have to search for benefits to your idea from different perspectives in order for it to be accepted."), //Needs examples
		]), 
		makeTopLevelCategoryNode("Architecture", [
			new KnowledgeNode(132, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Design", [
			new KnowledgeNode(102, DisplayMode.ITEM, "Read a book <a data-index='0'></a> for best results. (This is a temporary item until the category can be fleshed out.)", [
				new KnowledgeNode(103, DisplayMode.POP, "I recommend <a href='https://www.amazon.com/Design-Everyday-Things-Revised-Expanded-ebook/dp/B00E257T6C'>The Design of Everyday Things</a>."),
			]),
		]), 
		makeTopLevelCategoryNode("Legal", [
			new KnowledgeNode(133, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Programming", [
			new KnowledgeNode(134, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Documenting", [
			new KnowledgeNode(135, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Optimizing", [
			new KnowledgeNode(136, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Testing", [
			new KnowledgeNode(137, DisplayMode.ITEM, "To-do"),
		]),
		makeTopLevelCategoryNode("Publishing", [
			new KnowledgeNode(138, DisplayMode.ITEM, "To-do"),
		]),
	];
	
	//Add the major section nodes to the body
	var masterNode = document.getElementById("masternode");
	for (var x = 0; x < topNodes.length; x++) masterNode.appendChild(topNodes[x].toNode());
	
	//Inform developers what the current top KnowledgeNode ID is.
	var topFoundId = determineTopId();
	console.log("Current highest KnowledgeNode ID: " + topFoundId);
	console.assert(topFoundId <= highestUsedId, "Please update highestUsedId.");
};

//Call this from your browser's dev tools to keep track of the highest ID: determineTopId()
//(IDs should not be changed or reused, as it would break the users' save data. This is to help you find the newest ID in case you forgot.)
function determineTopId() {
	return KnowledgeNode.allNodes.length - 1; //Assumes that allNodes remains an array and has its elements directly set
}

/**
 * Get a list of objects with 'id' and 'date' corresponding to the KnowledgeNodes that are checked
 */
function getCheckedItems() {
	var checkedItems = [];
	for (var x = 0; x < KnowledgeNode.allNodes.length; x++) {
		if (KnowledgeNode.allNodes[x] && KnowledgeNode.allNodes[x].checked) 
			checkedItems.push({ id: x, date: KnowledgeNode.allNodes[x].checked });
	}
	return checkedItems;
}

/**
 * Save the IDs and checked-on dates of checked nodes to localStorage.
 * @throws {DOMException} (see documentation for localStorage.setItem)
 */
function saveToLocalStorage() {
	var idsAndDates = getCheckedItems();
	localStorage.setItem("CheckedItems", JSON.stringify(idsAndDates));
}

/**
 * Load the IDs and checked-on dates of checked nodes from localStorage.
 * Only call this before you create any KnowledgeNodes.
 */
function loadFromLocalStorage() {
	var idsAndDates = JSON.parse(localStorage.getItem("CheckedItems") || "[]");
	//Put the dates into the allNodes list.
	for (var x = 0; x < idsAndDates.length; x++) {
		KnowledgeNode.allNodes[idsAndDates[x].id] = new Date(idsAndDates[x].date);
	}
}

window.onbeforeunload = function(event) { //TODO: This doesn't occur if you hit refresh (in Chrome). Look for other events that may help; you want to just save every time the user touches a checkbox, but they may still need reminded to save their file locally.
	try {
		saveToLocalStorage();
	} catch {
		//TODO: Inform user that saving failed and maybe they want to save manually.
		//TODO: Only do so if they actually checked boxes, though.
	}
};

//Updating this project:
//Update this constant when you add a KnowledgeNode (for the sake of the next person who wants to add KnowledgeNodes or if someone removes the most recently added one that was published):
const highestUsedId = 139;
//Nodes should identify facts, ideas, principles, "best practices," shortcomings, and reasonable alteratives (aiding in pragmatism).
//Keep reasoning (if more than a few words), more esoteric knowledge (language-, domain-, or algorithm-specific), and examples in out-of-the-way places (like Pop items) while remembering that they may be independently displayed.
//Due to the vast array of languages, domains, and algorithms in existence, forks of this project (with none of the original KnowledgeNodes) may be necessary for anything that doesn't generalize well.
//Top-level categories don't have to make statements or suggestions, but others should do so to the extent feasible.
//References you have to pay for should always be listed last. Otherwise, it would be preferable to list the shortest ones first.
//Try to reduce repeat items by combining similar ones with a phrasing that allows them to apply to both, and then use the same item in both places.

/*
-----------------------------------
Knowledge items that need formatted
-----------------------------------

Being a great developer requires considering the human aspects of yourself, your teammates, your manager, and the users.
 
Deflect subtly and play the politics game, keeping the customer's best interests in mind.

People hire based on technologies despite that what programmers do best is learn new tech. As such, knowing old languages like COBOL can land you a high-paid position.
All decisions come with trade-offs. New, immature technologies tend to be inefficient, and most technologies don't advertise their glaring flaws. Things that improve maintainability in one way can also hurt it worse in another way. [See quality attribute matrix for general examples]
Maintaining a healthy body and mind is paramount to being a good developer, and that requires sleep, exercise, nutrition, and ergonomics. Being a considerate person is extremely important, too (see assertion #1 above).
Guidelines, principles, and best practices are not rules; they're not perfect and are not meant to be the best answer in every situation. What's always best is to weigh your options in context. The same applies for tools, technologies, and methodologies. Additionally, they're very hard to study, so you can't be sure how much they help solely based on speculation of their pros and cons [https://accu.org/index.php/journals/1547]. [Some discussion of the dubious benefits of pair programming: https://accu.org/index.php/journals/1983] [Some discussion of the difficulties involved in agile: https://accu.org/index.php/journals/2003]
Best practices and principles include KISS [Keep It Stupid-Simple], SOLID [Single Responsibility; Open/Closed; Liskov Substitution; Interface Segregation; Dependency Inversion: https://accu.org/index.php/journals/1957], DRY [Don't Repeat Yourself] [Cases to ignore DRY: https://accu.org/index.php/journals/2662], consistency, loose coupling (and dependency injection), leaky abstractions [https://www.joelonsoftware.com/2002/11/11/the-law-of-leaky-abstractions/], logic and documentation locality... Facts include "nothing is as simple as it seems." [https://www.joelonsoftware.com/2002/03/04/nothing-is-as-simple-as-it-seems/]
New technologies give you new ways of thinking, so try out a lot of languages and libraries. MATLAB/OCTAVE work with vector operations (SIMD--single instruction multiple data) so you often don't have to loop (see also: LINQ, map, reduce); functional languages like Haskell make you rely less on the program state and more on passing data around; declarative languages like VHDL give you a chance to break out of the sequence mindset.
Read some books (The Design of Everyday Things Revised and Expanded Edition, https://github.com/accu-org/essential-books/wiki ), and blogs (ITHare.com, GamaSutra, ACCU.org journals, https://devblogs.microsoft.com/oldnewthing/, maybe JoelOnSoftware.com) at different points in your life, not just technology-specific tutorials and articles.
Make improvement your responsibility. If you join a group and see that they have no overview-level documentation or list of common misunderstandings or anything to help newcomers get up to speed, it'll be helpful to everyone if you choose to be the one to create it.
Avoid interruptions. Every interruption resets your working memory, leading to a loss of 15-30 minutes of productivity.
Triple your initial estimates [http://programs.clearerthinking.org/how_well_anchored_are_your_estimates.html] or estimate with a confidence interval [https://accu.org/index.php/journals/1836]. Only make estimates for your own projects [https://www.joelonsoftware.com/2007/10/26/evidence-based-scheduling/], and break down projects that are more than a few days long to estimate them better. It's much easier to estimate how long something will take once you've actually thought about the challenges involved, but your estimates still need padded for bugs, interruptions, and test time.
Don't try to get even close to 100% automated test coverage in a non-safety-critical application. [http://ithare.com/too-much-unit-testing-is-detrimental-for-code-quality/] [http://ithare.com/testing-my-personal-take-on-testing-including-unit-testing-and-atddbdd/]
When writing code, especially if you don't have a formal design prepared in advance, write to-do comments explaining the process. You can take off the "TODO" as you complete these, and they become documentation of the intention behind sections of your code. This also serves as a guide and helps if you get interrupted or forget what you were doing.
Brainstorming consists of coming up with ideas and leaving their evaluation for later. [https://www.managers.org.uk/~/media/Files/Campus%20CMI/Checklists%20PDP/Brainstorming.ashx]
When you find a need to optimize your code (which requires first benchmarking to identify the slowest parts), first try reducing the run time complexity of the algorithms, such as changing a search into a hash-based lookup. If that proves insufficient, you may have to sacrifice clean, maintainable code for optimization. Compilers, particularly those for more mature programming languages, are very smart and capable of optimizing in a lot of ways, so you probably won't get anything out of simple changes [http://ithare.com/the-importance-of-back-of-envelope-estimates/]. However, compilers do not have problem domain knowledge and are restricted from performing some optimizations due to their general-purpose nature. In some cases, changing a class to a struct may result in a speed increase because it can increase cache locality and reduce redirection. Compilers for less mature languages may be unable to perform common optimizations like loop interchange and tail recursion. [https://en.wikipedia.org/wiki/Optimizing_compiler] [http://ithare.com/optimizing-big-number-arithmetic-without-sse/]
Fix bugs before implementing new features. Perform a proper root-cause analysis. Bugs can have hard-to-realize underlying causes that could affect new features. Their effects on other existing features could also go unnoticed.
No matter how minor you think a change is, test again after making it.
If someone questions a piece of code, add a comment addressing their concern (or rephrase an existing comment if it helps), because chances are good someone else will question it for the same reason eventually.
Remember your potential numeric ranges and font sizes when designing visuals like pie charts (e.g. how can you fit a label on a 1% sliver?) and raw text displays (word wrap? Word break? Scrolling?).
**Metrics
**Requirements elicitation (ambiguity is the greatest evil), requirements documents, requirements tracking
**Job hunting
**Anti-patterns
**Accessibility (colorblind, weak vision, blind, deaf)
**Globalization (language, encodings, decimals and commas, time zones, extra space for longer languages, right-to-left, fonts)
**Parallel execution
**Bonus: famous catch phrases. ITHare: Your Mileage May Vary. Lucian Radu Teodorescu (Do Repeat Yourself on ACCU): Don't Overdo It.
Automate everything that reasonably can be automated, such as pulling the code and all the tools and dependencies (which helps new team members get up to speed), building, test execution (which can be run during check-in), code formatting (which can be run constantly or during the build process), static analysis, and publishing (including packaging resources). If it takes more than two tasks, it's probably too much work. This acts as documentation, reducing unspoken knowledge. Infrequent things are just as important to automate as frequent things because humans forget them more easily.
Think about everything.
*/

//TODO: Go through the above items, check that they fit the project concept, and format them as code.
//TODO: Specify a standard for explanatory reasoning that doesn't qualify as a standalone knowledge item. (Basically, a Pop without a checkbox and with a "Why?" or "Examples" button instead of a "?" or whatever we settle on for references/external links to in-depth reasoning and examples.)
//TODO: Allow downloading + restoring the state of all your checkboxes (this feature plus the automatic localStorage one together, from the user's perspective, roughly equate to using a database while maintaining purely-local functionality for guaranteed privacy and offline use)
//TODO: Offer a link to continue where you left off (go to the most recently checked item)
/*Wishlist:
Voting
Sorting
Filtering
Searching (due to the collapsible categories). If I show them in random order until there are over 100 user votes on the importance of each of the items, then I can be temporarily confident that it's not a popularity contest (say, because I had a fixed order, most people would only read the first few items) or chance ordering.
For better startup performance if we have a ton of nodes in accordions, we might just generate the child DOM when the accordion expands and maybe delete the child DOM when the accordion collapses.
*/
</script>
</body>
</html>
